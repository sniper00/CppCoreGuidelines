# 哲学

这一章节是一些普通的规则。

哲学规则总结：

- [在代码中直接表达想法](#1)
- [编写ISO标准的C++代码](#2)
- [代码要清晰地表达含义](#3)
- [理想情况下，程序应该静态类型安全](#4)
- [优先使用编译期检查](#5)
- [在运行时应检查在编译时无法检查的内容](#6)
- [尽早捕获运行时错误](#7)
- [不要泄露任何资源](#8)
- [不要浪费时间或者空间](#9)
- [优先使用const类型](#10)
- [封装构造，不要采用凌乱的构造](#11)
- [适当的使用工具](#12)
- [根据需要使用第三方库](#13)


哲学规则通常不能用工具检查的。 然而，反映这些哲学主题的个别规则是可以的。 没有哲学基础，更具体/具体/可检查的规则缺乏理由依据。

<h2 id="1">在代码中直接表达想法</h2>

**原因** 编译器不会去读注释（或设计文档）通常程序员也不会。代码中已经定义的语义可以用编译器或者其他工具检查。

**示例**
```cpp
class Date {
    // ...
public:
    Month month() const;  // do
    int month();          // don't
    // ...
};
```

第一个函数month,确切的返回一个Month类型，并且不会修改Date对象的状态（const）。第二个month函数则留给人们更多的猜测空间，并且留下了造成更多bug的可能。

**示例**
```cpp
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    int index = -1;                    // bad
    for (int i = 0; i < v.size(); ++i) {
        if (v[i] == val) {
            index = i;
            break;
        }
    }
    // ...
}
```
这个循环如果采用std::find，表达式会更加清晰：
```cpp
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    auto p = find(begin(v), end(v), val);  // better
    // ...
}
```

一个精心设计的库能精确地表达意图（要做什么，而不仅仅是如何做什么），远比直接的使用语言特性好。


C ++程序员应该知道标准库的基础知识，并在适当的情况下使用它。 任何程序员应该知道正在处理的项目的基础库的基础知识，并适当地使用它们。 任何使用这些准则的程序员都应该知道指南支持库，并适当使用它。

**示例**
```cpp
change_speed(double s);   // bad: s 想要表达什么?
// ...
change_speed(2.3);
```
一个比较好地确切表达double s的含义（新的速度，增加的速度，或者旧的速度）并且表达 s的单位：
```cpp
change_speed(Speed s);    // better: the meaning of s is specified
// ...
change_speed(2.3);        // error: no unit
change_speed(23m / 10s);  // meters per second
```

这个函数可以接受一个double类型作为速度的递增值，但这样是错误的。如果我们需要同时表示绝对速度和递增值，可以定义一个Delta类型。

强制遵守这些普通的规则是困难的：
- 一直使用const（检查成员函数是否修改其对象;检查函数是否修改由指针或引用传递的参数）
- 显示使用类型转换（casts neuter the type system）
- 模拟标准库检测代码（困难）

<h2 id="2">编写ISO标准的C++代码</h2>

**原因** 这是编写ISO标准C++代码的一套指南。

**注意** 通常存在需要扩展的情况，例如访问系统资源。 在这种情况下，使用必要的本地化扩展，并通过非核心编码控制其使用。 如果可能，封装扩展接口，以便在不支持这些扩展的系统上关闭或不编译它们。

扩展通常没有严格定义的语义。 甚至由多个编译器实现的扩展也可能具有稍微不同的行为和边缘情况行为，这是由于没有严格的标准定义。 过度利用此类扩展，代码的可移植性将受到影响。

**注意** 使用有效的ISO c++并不能保证可移植性(更不用说正确性)。如避免依赖未定义的行为（如：未定义的算数求值顺序)和未定义的构造（sizeof(int)）。

**注意** 对标准C ++语言或库特征的使用环境限制是必要的，例如为了避免飞机控制软件标准所要求的动态内存分配。 在这种情况下，根据特定环境对这些编码指南的扩展进行控制（dis）使用。

使用最新的C++编译器(C++11,14...),不要使用编译器的扩展。

<h2 id="3">代码要清晰地表达含义</h2>

**原因** 除非一些代码能表达含义（例如，在命名或注释中），否则无法判断代码是否正确执行了。

**示例**
```cpp
int i = 0;
while (i < v.size()) {
    // ... do something with v[i] ...
}
```
这段代码不能直接表达仅仅是遍历`v`的元素。v的索引是直接暴露在外的，可能会被误用，并且`i`超出了循环的作用范围，能不能在循环之外使用， 其他人并不能从这段代码知道这些。

更好的方案：
```cpp
for (const auto& x : v) { /* do something with the value of x */ }
```
现在，没有明确提到迭代机制，循环对const引用元素进行操作，因此不会发生意外修改。如果需要修改，可以这样：
```cpp
for (auto& x : v) { /* modify x */ }
```

有时还有更好的选择,使用标准库算法：
```cpp
for_each(v, [](int x) { /* do something with the value of x */ });
for_each(par, v, [](int x) { /* do something with the value of x */ });
```
最后一个变体表明，我们对v的元素的处理顺序不感兴趣。

一个程序员需要熟悉：
- 指南支持库
- STL库
- 用于当前项目的基础库

**Note** Alternative formulation: Say what should be done, rather than just how it should be done. 

**Note** Some language constructs express intent better than others.

**示例** 如果用两个`int`表示2D坐标：
```cpp
draw_line(int, int, int, int);  // 费解的
draw_line(Point, Point);        // 清楚地
```

**Enforcement** 在常用模式中选择较好的方案
- 简单的for循环 vs range-for 循环
- f(T*, int) interfaces vs. f(span<T>) interfaces
- 注意循环中的变量，影响太大的范围
- 慎重直接使用new 和 delete
- 函数拥有太多基础类型的参数

这里有许多选择的余地。

<h2 id="4">理想情况下，程序应该静态类型安全</h2>

**原因** 理想情况下一个程序应该完全是编译期类型安全的。不幸的是，这不太可能，问题在于：
- unions
- casts
- array 衰退
- range errors
- narrowing conversions

**注意** 这些方便是严重问题的根源（崩溃，安全隐患）。我们尝试提供可选的技术来解决这个问题。

**Enforcement** 
